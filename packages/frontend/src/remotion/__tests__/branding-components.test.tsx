import { describe, it, expect, vi } from 'vitest';
import { render } from '@testing-library/react';
import { BrandedFrame } from '../components/branding/BrandedFrame';
import { ThemeProvider, useTheme, defaultTheme, darkTheme } from '../components/branding/ThemeProvider';
import { AnimatedButton } from '../components/ui/AnimatedButton';
import { LoadingSpinner } from '../components/ui/LoadingSpinner';

// Mock Remotion hooks and components
vi.mock('remotion', () => ({
  useCurrentFrame: () => 30,
  useVideoConfig: () => ({
    fps: 30,
    durationInFrames: 900,
    width: 1920,
    height: 1080,
  }),
  spring: () => 1,
  interpolate: (input: number, inputRange: number[], outputRange: number[]) => {
    const progress = Math.max(0, Math.min(1, (input - inputRange[0]) / (inputRange[1] - inputRange[0])));
    return outputRange[0] + progress * (outputRange[1] - outputRange[0]);
  },
  AbsoluteFill: ({ children, style }: any) => <div style={style}>{children}</div>,
}));

describe('Branding Components', () => {
  describe('BrandedFrame', () => {
    it('renders children with branding elements', () => {
      const { getByText } = render(
        <BrandedFrame aspectRatio="16:9" showLogo={true}>
          <div>Test Content</div>
        </BrandedFrame>
      );
      expect(getByText('Test Content')).toBeTruthy();
      expect(getByText('Video Creator')).toBeTruthy();
    });

    it('applies different themes', () => {
      const themes = ['light', 'dark', 'gradient'] as const;
      
      themes.forEach((theme) => {
        const { container } = render(
          <BrandedFrame aspectRatio="16:9" theme={theme}>
            <div>Content</div>
          </BrandedFrame>
        );
        expect(container.firstChild).toBeTruthy();
      });
    });

    it('handles different aspect ratios', () => {
      const aspectRatios = ['16:9', '9:16', '1:1'] as const;
      
      aspectRatios.forEach((aspectRatio) => {
        const { container } = render(
          <BrandedFrame aspectRatio={aspectRatio}>
            <div>Content</div>
          </BrandedFrame>
        );
        expect(container.firstChild).toBeTruthy();
      });
    });

    it('shows/hides watermark based on prop', () => {
      const { getByText, rerender } = render(
        <BrandedFrame aspectRatio="16:9" showWatermark={true}>
          <div>Content</div>
        </BrandedFrame>
      );
      expect(getByText('Generated by AI')).toBeTruthy();

      rerender(
        <BrandedFrame aspectRatio="16:9" showWatermark={false}>
          <div>Content</div>
        </BrandedFrame>
      );
      expect(() => getByText('Generated by AI')).toThrow();
    });
  });

  describe('ThemeProvider', () => {
    it('provides default theme', () => {
      let capturedTheme;
      
      const TestComponent = () => {
        capturedTheme = useTheme();
        return <div>Test</div>;
      };

      render(
        <ThemeProvider>
          <TestComponent />
        </ThemeProvider>
      );

      expect(capturedTheme).toEqual(defaultTheme);
    });

    it('provides custom theme', () => {
      let capturedTheme;
      
      const TestComponent = () => {
        capturedTheme = useTheme();
        return <div>Test</div>;
      };

      render(
        <ThemeProvider theme={darkTheme}>
          <TestComponent />
        </ThemeProvider>
      );

      expect(capturedTheme).toEqual(darkTheme);
    });

    it('throws error when used outside provider', () => {
      const TestComponent = () => {
        try {
          useTheme();
          return <div>Test</div>;
        } catch (error) {
          throw error;
        }
      };

      // Suppress console.error for this test
      const originalError = console.error;
      console.error = vi.fn();

      expect(() => render(<TestComponent />)).toThrow('useTheme must be used within a ThemeProvider');

      console.error = originalError;
    });
  });

  describe('AnimatedButton', () => {
    const renderWithTheme = (component: React.ReactElement) => {
      return render(
        <ThemeProvider>
          {component}
        </ThemeProvider>
      );
    };

    it('renders button with text', () => {
      const { getByText } = renderWithTheme(
        <AnimatedButton text="Click Me" />
      );
      expect(getByText('Click Me')).toBeTruthy();
    });

    it('applies different variants', () => {
      const variants = ['primary', 'secondary', 'outline'] as const;
      
      variants.forEach((variant, index) => {
        const { getByText } = renderWithTheme(
          <AnimatedButton text={`Test ${variant}`} variant={variant} />
        );
        expect(getByText(`Test ${variant}`)).toBeTruthy();
      });
    });

    it('applies different sizes', () => {
      const sizes = ['sm', 'md', 'lg'] as const;
      
      sizes.forEach((size) => {
        const { getByText } = renderWithTheme(
          <AnimatedButton text={`Test ${size}`} size={size} />
        );
        expect(getByText(`Test ${size}`)).toBeTruthy();
      });
    });

    it('handles different animation types', () => {
      const animationTypes = ['bounce', 'slide', 'fade', 'glow'] as const;
      
      animationTypes.forEach((animationType) => {
        const { getByText } = renderWithTheme(
          <AnimatedButton text={`Test ${animationType}`} animationType={animationType} />
        );
        expect(getByText(`Test ${animationType}`)).toBeTruthy();
      });
    });

    it('handles delay properly', () => {
      const { container } = renderWithTheme(
        <AnimatedButton text="Test" delay={60} />
      );
      // With delay=60 and current frame=30, the button should not render
      expect(container.querySelector('button')).toBeNull();
    });
  });

  describe('LoadingSpinner', () => {
    it('renders loading spinner', () => {
      const { container } = render(
        <LoadingSpinner />
      );
      expect(container.querySelector('svg')).toBeTruthy();
      expect(container.querySelector('circle')).toBeTruthy();
    });

    it('applies custom size', () => {
      const { container } = render(
        <LoadingSpinner size={60} />
      );
      const svg = container.querySelector('svg');
      expect(svg?.getAttribute('width')).toBe('60');
      expect(svg?.getAttribute('height')).toBe('60');
    });

    it('applies custom color', () => {
      const { container } = render(
        <LoadingSpinner color="#ff0000" />
      );
      const circle = container.querySelector('circle');
      expect(circle?.getAttribute('stroke')).toBe('#ff0000');
    });

    it('applies custom thickness', () => {
      const { container } = render(
        <LoadingSpinner thickness={6} />
      );
      const circle = container.querySelector('circle');
      expect(circle?.getAttribute('stroke-width')).toBe('6');
    });
  });
});